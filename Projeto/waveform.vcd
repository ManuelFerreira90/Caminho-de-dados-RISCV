$date
	Mon May 29 18:12:43 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module teste $end
$var wire 1 ! aluresult1 $end
$var wire 3 " tipo [2:0] $end
$var wire 5 # rs2 [4:0] $end
$var wire 5 $ rs1 [4:0] $end
$var wire 1 % regiwrite $end
$var wire 5 & rd [4:0] $end
$var wire 7 ' opcode [6:0] $end
$var wire 1 ( memwrite $end
$var wire 1 ) memread $end
$var wire 32 * instrucao [31:0] $end
$var wire 12 + immediate [11:0] $end
$var wire 7 , funct7 [6:0] $end
$var wire 3 - funct3 [2:0] $end
$var wire 1 . clk $end
$var wire 2 / aluop [1:0] $end
$var wire 4 0 alucontrol [3:0] $end
$var wire 32 1 PC [31:0] $end
$var reg 3 2 estado [2:0] $end
$scope module controlador $end
$var wire 1 ! aluresult1 $end
$var wire 3 3 tipo [2:0] $end
$var wire 3 4 funct3 [2:0] $end
$var wire 1 . clk $end
$var reg 4 5 alucontrol [3:0] $end
$var reg 2 6 aluop [1:0] $end
$var reg 1 ) memread $end
$var reg 1 ( memwrite $end
$var reg 1 % regiwrite $end
$upscope $end
$scope module decodificar $end
$var wire 32 7 instrucao [31:0] $end
$var wire 1 . clk $end
$var reg 3 8 funct3 [2:0] $end
$var reg 7 9 funct7 [6:0] $end
$var reg 12 : immediate [11:0] $end
$var reg 7 ; opcode [6:0] $end
$var reg 5 < rd [4:0] $end
$var reg 5 = rs1 [4:0] $end
$var reg 5 > rs2 [4:0] $end
$var reg 3 ? tipo [2:0] $end
$upscope $end
$scope module geraclk $end
$var reg 1 . clk $end
$upscope $end
$scope module leitura $end
$var wire 1 . clk $end
$var wire 32 @ PC [31:0] $end
$var reg 32 A instrucao [31:0] $end
$upscope $end
$scope module resultpc $end
$var wire 1 . clk $end
$var reg 32 B PC [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 B
bx A
b0 @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
b0 2
b0 1
bx 0
bx /
0.
bx -
bx ,
bx +
bx *
x)
x(
bx '
bx &
x%
bx $
bx #
bx "
z!
$end
#1
b1 2
b1 1
b1 @
b1 B
b110000011010000010000011 *
b110000011010000010000011 7
b110000011010000010000011 A
1.
#3
b11 '
b11 ;
0.
#4
b0 2
#5
b0 "
b0 3
b0 ?
b1100 +
b1100 :
b10 -
b10 4
b10 8
b11 $
b11 =
b1 &
b1 <
b1 2
b100011010011000100011 *
b100011010011000100011 7
b100011010011000100011 A
b10 1
b10 @
b10 B
1.
#7
b10 0
b10 5
1)
0(
b0 /
b0 6
1%
b1 +
b1 :
b1100 &
b1100 <
b100011 '
b100011 ;
0.
#8
b0 2
#9
b10 "
b10 3
b10 ?
b1 #
b1 >
b1100 +
b1100 :
b1 2
b11 1
b11 @
b11 B
b1000000011000110000001010110011 *
b1000000011000110000001010110011 7
b1000000011000110000001010110011 A
1.
#11
0)
1(
0%
b0 -
b0 4
b0 8
b110 #
b110 >
b110 $
b110 =
b10000000101 +
b10000000101 :
b110011 '
b110011 ;
0.
#12
b0 2
#13
b11 "
b11 3
b11 ?
b101 &
b101 <
b100000 ,
b100000 9
b1 2
b10100101100001010110011 *
b10100101100001010110011 7
b10100101100001010110011 A
b100 1
b100 @
b100 B
1.
#15
b110 0
b110 5
0(
b10 /
b10 6
1%
b100 -
b100 4
b100 8
b101 $
b101 =
b101 #
b101 >
b0 ,
b0 9
0.
#16
b0 2
#17
b10 0
b10 5
b1 2
b101 1
b101 @
b101 B
b101000011000000110010011 *
b101000011000000110010011 7
b101000011000000110010011 A
1.
#19
b0 -
b0 4
b0 8
b11 &
b11 <
b11 $
b11 =
b1010 #
b1010 >
b10011 '
b10011 ;
0.
#20
b0 2
#21
b110 0
b110 5
b1 2
b1100110101000110110011 *
b1100110101000110110011 7
b1100110101000110110011 A
b110 1
b110 @
b110 B
1.
#23
b110011 '
b110011 ;
0.
#24
b0 2
#25
b101 -
b101 4
b101 8
b110 $
b110 =
b11 #
b11 >
b1 2
b111 1
b111 @
b111 B
b11111110010100011000100011100011 *
b11111110010100011000100011100011 7
b11111110010100011000100011100011 A
1.
#27
b101 0
b101 5
b0 -
b0 4
b0 8
b10001 &
b10001 <
b11 $
b11 =
b101 #
b101 >
b1111111 ,
b1111111 9
b1100011 '
b1100011 ;
0.
#28
b110 2
#29
b110 "
b110 3
b110 ?
b111111110001 +
b111111110001 :
b110 0
b110 5
bx *
bx 7
bx A
b1000 1
b1000 @
b1000 B
1.
