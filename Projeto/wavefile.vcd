$date
	Mon May 29 19:16:16 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module main $end
$var wire 1 ! aluresult1 $end
$var wire 3 " tipo [2:0] $end
$var wire 5 # rs2 [4:0] $end
$var wire 5 $ rs1 [4:0] $end
$var wire 1 % regiwrite $end
$var wire 5 & rd [4:0] $end
$var wire 7 ' opcode [6:0] $end
$var wire 1 ( memwrite $end
$var wire 1 ) memread $end
$var wire 32 * instrucao [31:0] $end
$var wire 12 + immediate [11:0] $end
$var wire 7 , funct7 [6:0] $end
$var wire 3 - funct3 [2:0] $end
$var wire 1 . clk $end
$var wire 2 / aluop [1:0] $end
$var wire 4 0 alucontrol [3:0] $end
$var wire 32 1 PC [31:0] $end
$var reg 3 2 estado [2:0] $end
$scope module controlador $end
$var wire 1 ! aluresult1 $end
$var wire 3 3 tipo [2:0] $end
$var wire 3 4 funct3 [2:0] $end
$var wire 1 . clk $end
$var reg 4 5 alucontrol [3:0] $end
$var reg 2 6 aluop [1:0] $end
$var reg 1 ) memread $end
$var reg 1 ( memwrite $end
$var reg 1 % regiwrite $end
$upscope $end
$scope module decodificar $end
$var wire 32 7 instrucao [31:0] $end
$var wire 1 . clk $end
$var reg 3 8 funct3 [2:0] $end
$var reg 7 9 funct7 [6:0] $end
$var reg 12 : immediate [11:0] $end
$var reg 7 ; opcode [6:0] $end
$var reg 5 < rd [4:0] $end
$var reg 5 = rs1 [4:0] $end
$var reg 5 > rs2 [4:0] $end
$var reg 3 ? tipo [2:0] $end
$upscope $end
$scope module geraclk $end
$var reg 1 . clk $end
$upscope $end
$scope module leitura $end
$var wire 1 . clk $end
$var wire 32 @ PC [31:0] $end
$var reg 32 A instrucao [31:0] $end
$upscope $end
$scope module resultpc $end
$var wire 1 . clk $end
$var reg 32 B PC [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 B
bx A
b0 @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
b0 2
b0 1
bx 0
bx /
0.
bx -
bx ,
bx +
bx *
x)
x(
bx '
bx &
x%
bx $
bx #
bx "
z!
$end
#1
b1 1
b1 @
b1 B
b110000011010000010000011 *
b110000011010000010000011 7
b110000011010000010000011 A
b1 2
1.
#3
0.
#5
b11 '
b11 ;
b100011010011000100011 *
b100011010011000100011 7
b100011010011000100011 A
b10 1
b10 @
b10 B
1.
#6
b0 2
#7
0.
#9
b11 1
b11 @
b11 B
b1000000011000110000001010110011 *
b1000000011000110000001010110011 7
b1000000011000110000001010110011 A
b0 "
b0 3
b0 ?
b1 +
b1 :
b10 -
b10 4
b10 8
b11 $
b11 =
b1100 &
b1100 <
b100011 '
b100011 ;
b1 2
1.
#11
0.
#13
b10 0
b10 5
1)
0(
b0 /
b0 6
1%
b10 "
b10 3
b10 ?
b0 -
b0 4
b0 8
b110 #
b110 >
b110 $
b110 =
b10000000101 +
b10000000101 :
b110011 '
b110011 ;
b10100101100001010110011 *
b10100101100001010110011 7
b10100101100001010110011 A
b100 1
b100 @
b100 B
1.
#14
b0 2
#15
0.
#17
b101 1
b101 @
b101 B
b101000011000000110010011 *
b101000011000000110010011 7
b101000011000000110010011 A
b11 "
b11 3
b11 ?
b100 -
b100 4
b100 8
b101 &
b101 <
b101 $
b101 =
b101 #
b101 >
b0 ,
b0 9
0)
1(
0%
b1 2
1.
#19
0.
#21
0(
b10 /
b10 6
1%
b0 -
b0 4
b0 8
b11 &
b11 <
b11 $
b11 =
b1010 #
b1010 >
b10011 '
b10011 ;
b1100110101000110110011 *
b1100110101000110110011 7
b1100110101000110110011 A
b110 1
b110 @
b110 B
1.
#22
b0 2
#23
0.
#25
b111 1
b111 @
b111 B
b11111110010100011000100011100011 *
b11111110010100011000100011100011 7
b11111110010100011000100011100011 A
b110011 '
b110011 ;
b110 0
b110 5
b1 2
1.
#27
0.
#29
b10001 &
b10001 <
b101 #
b101 >
b1111111 ,
b1111111 9
b1100011 '
b1100011 ;
bx *
bx 7
bx A
b1000 1
b1000 @
b1000 B
1.
#30
b110 2
#31
0.
#33
b1001 1
b1001 @
b1001 B
b110 "
b110 3
b110 ?
bx -
bx 4
bx 8
bx #
bx >
bx $
bx =
bx +
bx :
bx '
bx ;
1.
