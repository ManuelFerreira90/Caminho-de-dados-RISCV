$date
	Tue May 30 19:42:55 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module main $end
$var wire 32 ! writedataR [31:0] $end
$var wire 3 " tipo [2:0] $end
$var wire 5 # rs2 [4:0] $end
$var wire 5 $ rs1 [4:0] $end
$var wire 1 % regiwrite $end
$var wire 32 & readdata2R [31:0] $end
$var wire 32 ' readdata1R [31:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 1 ) pcsrc $end
$var wire 7 * opcode [6:0] $end
$var wire 1 + memwrite $end
$var wire 1 , memtoreg $end
$var wire 1 - memread $end
$var wire 32 . instrucao [31:0] $end
$var wire 12 / immediate [11:0] $end
$var wire 7 0 funct7 [6:0] $end
$var wire 3 1 funct3 [2:0] $end
$var wire 1 2 clk $end
$var wire 1 3 branch $end
$var wire 1 4 alusrc $end
$var wire 32 5 aluresult2 [31:0] $end
$var wire 32 6 aluresult1 [31:0] $end
$var wire 4 7 alucontrol [3:0] $end
$var wire 32 8 PC [31:0] $end
$var reg 3 9 estado [2:0] $end
$scope module alu $end
$var wire 32 : readdata2R [31:0] $end
$var wire 32 ; readdata1R [31:0] $end
$var wire 12 < immediate [11:0] $end
$var wire 1 2 clk $end
$var wire 1 3 branch $end
$var wire 1 4 alusrc $end
$var wire 4 = alucontrol [3:0] $end
$var reg 32 > aluresult1 [31:0] $end
$var reg 32 ? aluresult2 [31:0] $end
$var reg 1 ) pcsrc $end
$upscope $end
$scope module clock $end
$var reg 1 2 clk $end
$upscope $end
$scope module decodificacao $end
$var wire 1 2 clk $end
$var wire 32 @ instrucao [31:0] $end
$var reg 3 A funct3 [2:0] $end
$var reg 7 B funct7 [6:0] $end
$var reg 12 C immediate [11:0] $end
$var reg 7 D opcode [6:0] $end
$var reg 5 E rd [4:0] $end
$var reg 5 F rs1 [4:0] $end
$var reg 5 G rs2 [4:0] $end
$var reg 3 H tipo [2:0] $end
$upscope $end
$scope module lerinstrucao $end
$var wire 1 2 clk $end
$var wire 32 I PC [31:0] $end
$var reg 32 J instrucao [31:0] $end
$upscope $end
$scope module registradores $end
$var wire 1 2 clk $end
$var wire 5 K rd [4:0] $end
$var wire 5 L rs1 [4:0] $end
$var wire 5 M rs2 [4:0] $end
$var wire 32 N writedataR [31:0] $end
$var wire 1 % regiwrite $end
$var reg 32 O readdata1R [31:0] $end
$var reg 32 P readdata2R [31:0] $end
$upscope $end
$scope module sinaisdecontrole $end
$var wire 1 2 clk $end
$var wire 3 Q funct3 [2:0] $end
$var wire 3 R tipo [2:0] $end
$var reg 4 S alucontrol [3:0] $end
$var reg 2 T aluop [1:0] $end
$var reg 1 4 alusrc $end
$var reg 1 3 branch $end
$var reg 1 - memread $end
$var reg 1 , memtoreg $end
$var reg 1 + memwrite $end
$var reg 1 % regiwrite $end
$upscope $end
$scope module somapc $end
$var wire 1 2 clk $end
$var wire 12 U immediate [11:0] $end
$var wire 1 ) pcsrc $end
$var reg 32 V PC [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bz N
bx M
bx L
bx K
bx J
b0 I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
b0 9
b0 8
bx 7
bx 6
bx 5
x4
x3
02
bx 1
bx 0
bx /
bx .
x-
x,
x+
bx *
x)
bx (
bx '
bx &
x%
bx $
bx #
bx "
bz !
$end
#1
b1 8
b1 I
b1 V
b10000000010000010000011 .
b10000000010000010000011 @
b10000000010000010000011 J
b1 9
12
#3
02
#5
b0 9
b11 *
b11 D
b1000000100110011 .
b1000000100110011 @
b1000000100110011 J
b10 8
b10 I
b10 V
12
#7
02
#9
b11 8
b11 I
b11 V
b1000001000000010110011 .
b1000001000000010110011 @
b1000001000000010110011 J
b0 "
b0 H
b0 R
b0 /
b0 <
b0 C
b0 U
b0 1
b0 A
b0 Q
b1 $
b1 F
b1 L
b10 (
b10 E
b10 K
b110011 *
b110011 D
b1 9
12
#11
02
#13
b0 9
b111 '
b111 ;
b111 O
14
1,
03
b10 7
b10 =
b10 S
1-
0+
1%
b11 "
b11 H
b11 R
b1 (
b1 E
b1 K
b10 #
b10 G
b10 M
b0 0
b0 B
b100 8
b100 I
b100 V
12
#15
02
#17
b101 8
b101 I
b101 V
b1000000001000001000000010110011 .
b1000000001000001000000010110011 @
b1000000001000001000000010110011 J
04
0,
b110 7
b110 =
b110 S
0-
b0 &
b0 :
b0 P
0)
b0 6
b0 >
b111 5
b111 ?
b1 9
12
#19
02
#21
b0 9
bz '
bz ;
bz O
b100000 0
b100000 B
b110 8
b110 I
b110 V
12
#23
02
#25
b111 8
b111 I
b111 V
b1000001000011001100011 .
b1000001000011001100011 @
b1000001000011001100011 J
bx 5
bx ?
b1 9
12
#27
02
#29
b110 9
b1100 (
b1100 E
b1100 K
b0 0
b0 B
b1100011 *
b1100011 D
bx .
bx @
bx J
b1000 8
b1000 I
b1000 V
12
#31
02
#33
b1001 8
b1001 I
b1001 V
b110 "
b110 H
b110 R
bx 1
bx A
bx Q
bx #
bx G
bx M
bx $
bx F
bx L
bx /
bx <
bx C
bx U
bx *
bx D
12
